# More Functional Patterns

## Exercises: Grab Bag
Note the following exercises are from source code files, not written
for use directly in the REPL. Of course, you can change them to test
directly in the REPL if you prefer.
1. Which (two or more) of the following are equivalent?
   
    a) mTh x y z = x * y * z

    b) mTh x y = \z -> x * y * z

    c) mTh x = \y -> \z -> x * y * z

    d) mTh = \x -> \y -> \z -> x * y * z

    All are equivalent.

2. The type of mTh (above) is Num a => a -> a -> a -> a.
Which is the type of mTh 3?

    a) Integer -> Integer -> Integer

    b) Num a => a -> a -> a -> a

    c) Num a => a -> a

    d) Num a => a -> a -> a

    Answer d)

    ![Output](img/cmd55.png)

3. Next, we’ll practice writing anonymous lambda syntax.
For example, one could rewrite:
    ```haskell
    addOne x = x + 1
    ```
    Into:
    ```haskell
    addOne = \x -> x + 1
    ```
    Try to make it so it can still be loaded as a top-level definition by GHCi. This will make it easier to validate your answers.

    a) Rewrite the f function in the where clause.
    ```haskell
    addOneIfOdd n = case odd n of
        True -> f n
        False -> n
        where f n = n + 1
    ```

    ```Haskell
    addOneIfOdd = \n -> case odd n of
    True -> f n
    False -> n
    where f n = n + 1
    ```
    ![Output](img/cmd56.png)

    b) Rewrite the following to use anonymous lambda syntax:
    ```haskell
    addFive x y = (if x > y then y else x) + 5
    ```

    ```haskell
    addFive = \x -> \y -> (if x > y then y else x) + 5
    ```

    ![Output](img/cmd57.png)

    c) Rewrite the following so that it doesn’t use anonymous
    lambda syntax:
    ```haskell
    mflip f = \x -> \y -> f y x
    ```

    ```haskell
    mflip = \f -> \x -> \y -> f y x

    y = 1 
    x = 2 
    f y x = x + y
    ```

    ![Output](img/cmd58.png)


## Exercises: Variety Pack
1. Given the following declarations
    ```Haskell
    k (x, y) = x
    k1 = k ((4-1), 10)
    k2 = k ("three", (1 + 2))
    k3 = k (3, True)
    ```

    a) What is the type of k?

        K is of type Tuple

    b) What is the type of k2? Is it the same type as k1 or k3?

        k2 is of type tuple same as k1 and k3.

    c) Of k1, k2, k3, which will return the number 3 as the result?

        k1 and k3
1. Fill in the definition of the following function:
    ```Haskell
    -- Remember: Tuples have the same syntax for their
    -- type constructors and their data constructors.
    f :: (a, b, c) -> (d, e, f) -> ((a, d), (c, f))
    f = undefined
    ```

    ```haskell
    f :: (a, b, c) -> (d, e, f) -> ((a, d), (c, f))
    f (a,b,c) (d,e,f)= ((a, d), (c, f))
    ```

    ![Output](img/cmd59.png)

## Exercises: Case Practice
We’re going to practice using case expressions by rewriting functions.
Some of these functions you’ve seen in previous chapters (and some
you’ll see later using different syntax yet again!), but you’ll be writing
new versions now. Please note these are all written as they would be
in source code files, and we recommend you write your answers in
source files and then load into GHCi to check, rather than trying to
do them directly into the REPL.
First, rewrite `if-then-else` expressions into case expressions.
1. The following should return x when x is greater than y.
    ```haskell
    functionC x y = if (x > y) then x else y
    ```
    ```haskell
    functionC x y =
    case check of
        True -> x
        False -> y
    where check = x > y
    ```
    ![Output](img/cmd60.png)

2. The following will add 2 to even numbers and otherwise simply
return the input value.
    ```Haskell
    ifEvenAdd2 n = if even n then (n+2) else n
    ```

    ```haskell
    ifEvenAdd2 n =
    case even n of
        True -> n + 2
        False -> n
    ```
    ![Output](img/cmd61.png)

The next exercise doesn’t have all the cases covered. See if you
can fix it.

3. The following compares a value, x, to zero and returns an indicator
for whether x is a postive number or negative number. But
what if x is 0? You may need to play with the compare function a
bit to find what to do.
    ```haskell
    nums x =
        case compare x 0 of
            LT -> -1
            GT -> 1
    ```
    ```
    nums x =
        case compare x 0 of
            LT -> -1
            GT -> 1
            EQ -> 0
    ```
    ![Output](img/cmd62.png)
