# Functor

## Exercises: Be Kind
Given a type signature, determine the kinds of each type variable:
1. What’s the kind of 𝑎?

    a -> a

    ```haskell
    *
    ```

2. What are the kinds of 𝑏 and 𝑇 ? (The 𝑇 is capitalized on purpose!)
    
    a -> b a -> T (b a)

    ```haskell
    b
    * -> *
    T
    * -> *
    ```
3. What’s the kind of 𝑐?
    
    c a b -> c b a

    ```haskell
    * -> * -> *
    ```

## Exercises: Heavy Lifting
Add fmap, parentheses, and function composition to the expression
as needed for the expression to typecheck and produce the expected
result. It may not always need to go in the same place, so don’t get
complacent.
1. ```haskell
   a = (+1) $ read "[1]" :: [Int]
   ```
     
    Expected result
    ```haskell
    Prelude> a
    [2]
    ```

    ```haskell
   a = fmap (+1) $ read "[1]" :: [Int]
   ```
2. ```haskell
   b = (++ "lol") (Just ["Hi,", "Hello"])
   ```
    ```haskell
    Prelude> b
    Just ["Hi,lol","Hellolol"]
    ```
3. ```haskell
   c = (*2) (\x -> x - 2)
   ```
    ```haskell
    Prelude> c 1
    -2
    ```
4. ```haskell
   d = ((return '1' ++) . show) (\x -> [x, 1..3])
   ```
    ```haskell
    Prelude> d 0
    "1[0,1,2,3]"
    ```
5. ```haskell
    e :: IO Integer
    e = let ioi = readIO "1" :: IO Integer
            changed = read ("123"++) show ioi
        in (*3) changed
    ```
    ```haskell
    Prelude> e
    3693
    ```