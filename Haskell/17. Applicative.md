# Applicative

The more core operation of this typeclass is <*>. This is an infix function
called ‘apply’ or sometimes ‘ap,’ or sometimes ‘tie-fighter’ when we’re
feeling particularly zippy.

## Exercises: Lookups
In the following exercises you will need to use the following terms
to make the expressions type-check:
1. ```
   pure
   ```
2. ```haskell
   (<$>)
    -- or fmap
    ```
3. ```haskell
   (<*>)
   ```
Make the following expressions type-check.
1. ```haskell
   added :: Maybe Integer
   added = (+3) (lookup 3 $ zip [1, 2, 3] [4, 5, 6])
   ```
    ```haskell
    added :: Maybe Integer
    added = (+3) <$> (lookup 3 $ zip [1, 2, 3] [4, 5, 6])
    ```
2. ```haskell
   y :: Maybe Integer
    y = lookup 3 $ zip [1, 2, 3] [4, 5, 6]
    z :: Maybe Integer
    z = lookup 2 $ zip [1, 2, 3] [4, 5, 6]
    tupled :: Maybe (Integer, Integer)
    tupled = (,) y z
    ```
    ```haskell
    y :: Maybe Integer
    y = lookup 3 $ zip [1, 2, 3] [4, 5, 6]

    z :: Maybe Integer
    z = lookup 2 $ zip [1, 2, 3] [4, 5, 6]

    tupled :: Maybe (Integer, Integer)
    tupled = (,) <$> y <*> z
    ```
3. ```haskell
   import Data.List (elemIndex)
    x :: Maybe Int
    x = elemIndex 3 [1, 2, 3, 4, 5]
    y :: Maybe Int
    y = elemIndex 4 [1, 2, 3, 4, 5]
    max' :: Int -> Int -> Int
    max' = max
    maxed :: Maybe Int
    maxed = max' x y
    ```
    ```haskell
    x :: Maybe Int
    x = elemIndex 3 [1, 2, 3, 4, 5]

    y :: Maybe Int
    y = elemIndex 4 [1, 2, 3, 4, 5]

    max' :: Int -> Int -> Int
    max' = max

    maxed :: Maybe Int
    maxed = max' <$>  x <*> y
    ```
4. ```haskell
    xs = [1, 2, 3]
    ys = [4, 5, 6]
    x :: Maybe Integer
    x = lookup 3 $ zip xs ys
    y :: Maybe Integer
    y = lookup 2 $ zip xs ys
    summed :: Maybe Integer
    summed = sum $ (,) x y
    ```
    ```haskell
    xs = [1, 2, 3]

    ys = [4, 5, 6]

    x :: Maybe Integer
    x = lookup 3 $ zip xs ys

    y :: Maybe Integer
    y = lookup 2 $ zip xs ys

    summed :: Maybe Integer
    summed = sum <$> ((,) <$> x <*> y)
    ```
## Exercise: Identity Instance
Write an Applicative instance for Identity.
```haskell
newtype Identity a = Identity a deriving (Eq, Ord, Show)

instance Functor Identity where
    fmap = undefined

instance Applicative Identity where
    pure = undefined
    (<*>) = undefined
```

## Exercise: Constant Instance
Write an Applicative instance for Constant.
```haskell
newtype Constant a b = Constant { getConstant :: a } deriving (Eq, Ord, Show)

instance Functor (Constant a) where
    fmap = undefined   

instance Monoid a => Applicative (Constant a) where
    pure a = Constant e a
    (<*>) = Constant e (a -> b) -> Constant e a -> Constant e b
```